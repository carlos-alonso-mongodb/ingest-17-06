#!/usr/bin/env python3
"""
reverse_unflatten.py  Â·  CatSalut CDR â‡¢ openEHR (draft v0.7 â€“ 2025-06-12)
-----------------------------------------------------------------------
Re-creates an **openEHR canonical JSON composition** from the flattened
representation generated by the CatSalut CDR ingestor (v12.1 or newer).

The script assumes **two tiny additions** have been made to each `cn[]`
node during flattening so that the process is *perfectly* invertible:

1. **kp** â€“ *key-path* (list[str]) â€“ the exact attribute path inside the
   parent node where the child node must be inserted, e.g.:
       ["cx", "oc", "i"]            â†’  context.other_context.items
   It is relative to the *nearest archetyped* ancestor.

2. **li** â€“ *list index* (int | None) â€“ preserves the ordering when the
   parent attribute is a list (â‰ˆ `items`, `content`, `events` â€¦).  For an
   attribute that is *not* a list the value is `None` (or simply absent).

Both fields can be kept short-handed if you prefer (`kp`/`li`) â€“ the
script does **key expansion** via the `_shortcuts` collection.

Dependencies
------------
Python â‰¥ 3.10 plus `python-dateutil` (for ISO dates) and `pymongo`
*only* if you want to fetch the `_codes` / `_shortcuts` directly from a
MongoDB.  Pure local dicts work just as well for unit tests.

Usage
-----
    from reverse_unflatten import rebuild_composition, load_codebook, load_shortcuts

    flat   = mongo.db.compositions.find_one({"_id": <ObjectId>})
    codes  = load_codebook(mongo.db._codes)              # or pass dicts
    shorts = load_shortcuts(mongo.db._shortcuts)

    comp   = rebuild_composition(flat, codes, shorts)

The returned *comp* is a **deep-copy** of the original canonical JSON
(sans stray fields trimmed by the forward flattener).  You are free to
serialise it, validate it, or round-trip it back to an openEHR CDR.
"""
from __future__ import annotations

import copy
from typing import Any, Dict, List, Optional
from itertools import chain

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Helpers to (1) expand shortcuts and (2) decode ani â†’ archetype/at-id
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ShortcutExpander:
    def __init__(self, keys: Dict[str, str], values: Dict[str, str]):
        # short â†’ long maps for O(1) lookup
        self._k_short2long = {v: k for k, v in keys.items()}
        self._v_short2long = {v: k for k, v in values.items()}

    # helper for kp tokens
    def key_long(self, short: str) -> str:
        return self._k_short2long.get(short, short)

    # deep expansion
    def __call__(self, obj: Any, *, _inside_t: bool = False) -> Any:
        if isinstance(obj, dict):
            return {self.key_long(k): self(v, _inside_t=(k == "T"))
                    for k, v in obj.items()}
        if isinstance(obj, list):
            return [self(x, _inside_t=_inside_t) for x in obj]
        if isinstance(obj, str) and _inside_t:
            # only expand short values when we are inside the "T" tag
            return self._v_short2long.get(obj, obj)
        return obj


class CodeBook:
    def __init__(self, ar_map: Dict[str, int], at_map: Dict[str, int]):
        self._ar = {v: k for k, v in ar_map.items()}
        self._at = {v: k for k, v in at_map.items()}

    def decode(self, code: int) -> str:
        if code >= 0:
            return self._ar.get(code, str(code))
        # always prefer the padded form
        raw = self._at.get(code)
        if raw is not None and raw.lower().startswith("at"):
            return f"at{int(raw[2:]):04d}"     # re-pad
        return f"at{-code:04d}"


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Core reconstruction engine
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _compact(obj: Any) -> Any:
    """
    Recursively walk *obj* and turn every list into a dense list by
    dropping all `None` placeholders left by _insert_at().
    """
    if isinstance(obj, list):
        return [_compact(x) for x in obj if x is not None]
    if isinstance(obj, dict):
        return {k: _compact(v) for k, v in obj.items()}
    return obj


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3. _insert_at() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _insert_at(parent: Dict[str, Any],
               kp: List[str],
               value: Dict[str, Any],
               li: Optional[int],
               expander: ShortcutExpander) -> None:
    """
    Insert *value* into *parent* following *kp* (key-path) and optional
    list-index *li*.  If *li* points to an already filled slot we now
    **append** instead of overwriting so that siblings are preserved.
    """
    cur: Dict[str, Any] = parent
    last = len(kp) - 1

    for idx, token in enumerate(kp):
        key = expander.key_long(token)          # short â†’ long
        if idx == last:                         # â”€â”€ leaf level â”€â”€
            if li is None:                      # plain attribute
                cur[key] = value
            else:                               # list attribute
                arr = cur.setdefault(key, [])
                # grow list if necessary
                while len(arr) <= li:
                    arr.append(None)

                if arr[li] is None:             # slot free â†’ normal case
                    arr[li] = value
                else:
                    #  ðŸ†•  slot taken  â†’ keep original, append newcomer
                    arr.append(value)
            return

        # â”€â”€ descend â”€â”€
        cur = cur.setdefault(key, {})


def rebuild_composition(flat_doc: Dict[str, Any],
                        codes: CodeBook,
                        expander: ShortcutExpander) -> Dict[str, Any]:
    """Recreate the canonical openEHR composition from one flattened doc."""

    path2obj: Dict[str, Dict[str, Any]] = {}   # current node for each path
    root: Optional[Dict[str, Any]] = None

    for node in flat_doc["cn"]:                       # keep original order
        d_raw = copy.deepcopy(node["d"])
        ani   = d_raw.pop("ani")
        kp    = node.get("kp") or [node.get("ak")]
        li    = node.get("li")

        # expand shortcuts & decode archetype node id
        obj = expander(d_raw)
        obj["archetype_node_id"] = codes.decode(ani)

        path          = node["p"]
        parent_path   = path.split(".", 1)[1] if "." in path else None

        if parent_path is None:                       # â†³ root composition
            root = obj
        else:
            parent_obj = path2obj[parent_path]        # must already exist
            _insert_at(parent_obj, kp, obj, li, expander)

        path2obj[path] = obj                          # (re-)map for children

    if root is None:                                  # defensive
        raise ValueError("no root composition found")

    return _compact(root)                             # drop None placeholders

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Convenience loaders (Mongo optional)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def load_codebook(codes_doc: Dict[str, Any] | Any) -> CodeBook:
    """`codes_doc` can be a raw dict or a PyMongo document."""
    ar_map = {}
    at_map = codes_doc.get("at", {})
    for rm, subtree in codes_doc.items():
        if rm.startswith("_") or rm in ("at",):
            continue
        for name, vers in subtree.items():
            for ver, code in vers.items():
                ar_map[f"{rm}.{name}.{ver}"] = code
    return CodeBook(ar_map, at_map)


def load_shortcuts(short_doc: Dict[str, Any] | Any) -> ShortcutExpander:
    keys   = short_doc.get("keys", {})
    values = short_doc.get("values", {})
    return ShortcutExpander(keys, values)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  Simple CLI for ad-hoc testing
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    import argparse, json, sys

    p = argparse.ArgumentParser(description="Rebuild openEHR composition from flattened JSON")
    p.add_argument("flat",  help="flattened composition JSON file")
    p.add_argument("codes", help="_codes JSON file with mappings")
    p.add_argument("short", help="_shortcuts JSON file")
    args = p.parse_args()

    flat_doc   = json.load(open(args.flat,  encoding="utf-8"))
    codes_doc  = json.load(open(args.codes, encoding="utf-8"))
    short_doc  = json.load(open(args.short, encoding="utf-8"))

    comp = rebuild_composition(flat_doc, load_codebook(codes_doc), load_shortcuts(short_doc))
    json.dump(comp, sys.stdout, indent=2, ensure_ascii=False)
    sys.stdout.write("\n")























